3/8
스프링이란 무엇인가
	1. 프레임워크
		프레임워크 = 틀 내에서 문제를 해결하는 데 사용되는 도구
	2. 오픈소스
		소스코드가 공개, 내부를 고칠 수 있다.(나중 이야기)
		무료
	3. IoC 컨테이너를 가짐
			IoC = Inversion of Controll 제어권의 역전
		객체의 생성을 책임지고 의존성을 관리한다.
		class 설계도, 변수와 메서드의 집합
		object 객체, 구현할 대상, 클래스에 선언된 모양 그대로 생성된 실체
		instance 구현된 구체적인 실체, 메모리에 할당되어 실제 사용됨 : 객체>인스턴스
		class  	-필드 : 속성을 표현
				-메소드 : 기능을 표현
		ex>
			오브젝트 (메서드)

			의자 s= new 의자();

			public void make(){
					의자 s= new 의자(); --------A	heap 메모리(컨테이너)에 둘이 올라감
			}                               			A,B 둘은 다른 의자 (이렇게 될 시 공유하기 힘들어짐)
			public void use(){                 			=> 스프링이 객체들을 잇는다
					의자 s= new 의자(); --------B
			}
			IoC 스프링이 객체들을 읽고 메모리에 올려줌
	4. DI지원
			내가 원하는 모든 메소드에서 메모리에 저장된 객체들을 사용할 수 있음(싱글톤)
	5. 많은 필터
			필터 = HTTP요청과 응답을 변경할 수 있는 코드(객체),
			톰캣 => 필터(web.xml)
			스프링컨테이너 => 인터셉터(AoP)
	6. 많은 어노테이션
			컴파인체킹
			어노테이션(주석+힌트) <- 컴파일러가 무시x
			리플렉션(어떤 클래스가 어떤것들을 들고있는지 분석하는 기법-> 런타입시 분석)=>
			//(주석) <-컴파일러가 무시
			스프링-> 어노테이션으로 객체 생성
			ex> 	@compont-> 클래스 메모리에 로딩
					@Autowired -> 로딩된 객체를 해당 변수에 집어넣어
						@compont        IoC(스캔)	(라는 약속이 있을때)
						class A S <---------------heap메모리 공간에 A 로드
						class B{
							@Autowired      분석(리플렉션)
							A a;            (heap메모리 공간에 있는 A가 들어감)
						}

// 무슨 말인지 이해 못하겠음, 자바 공부 시작

3/13
// 자바공부 일단락 다시 스프링 개념공부 시작.

	7. 스프링은 MessageConverter을 가지고 있고, 기본값은 현재 Json이다.
		Json=> 중간언어 
		ex>	자바오브젝트 <---json---> 파이썬오브젝트
		메시지컨버터
			자바오브젝트를 다른 곳으로 전송할 때 중간데이터인 Json으로 컨버터해주는 것
	
		자바오브젝트---메시지컨버터:Jackson(Json데이터로 변경해주는 라이브러리)---Json--->>파이썬프로그램

	8. 스프링은 BufferedReader와 BufferedWriter를 쉽게 사용할 수 있다.
		8비트= 1바이트 : 통신의 단위

		ByteStream(1바이트를 보냄)->InputStream	->Char(복잡함)
											->InputStreamReader(바이트를 문자로 바꿔 문자 1개를 준다. or 배열로 여러개의 문자를 받을 수 있음)
													but 배열은 크기를 정해줘야함(공간 낭비가 심해서 안씀)
											->BufferedReader(가변길이의 문자를 받을 수 있다.)
		상대방이 데이터를 요청할 때 요청 때 담겨진 데이터를 BufferedReader로 받는다. (ex>request.getReader())
		이후 데이터를 쓸 때도 BufferedWriter(내려쓰기가 없어서 java에서는 주로 Printwriter(ex> print(), println()) 를 쓴다.) 를 쓴다.
		즉 BufferedWriter는 ByteStream를 통해서 전송할 때 전송단위가 문자열로 가변길이의 데이터를 쓰게 해주는 클래스=>어노테이션 @ResponseBody -> BufferedWriter 동작
																															@RequestBody -> BufferedReader 동작

JPA란 무엇인가
	1. Java Persistence API 이다.
		Persistence: 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성
			ex> RAM(전기로 저장): 휘발성 데이터(컴퓨터 꺼질시 데이터 다 사라짐) -> 하드디스크(기록):비휘발성
		JPA: 자바에 있는 데이터를 영구히 기록할 수 있는 환경의 API
		API: 애플리케이션 프로그래밍 인터페이스, 프로그램을 프로그래밍하는 인터페이스
			인터페이스: 		프로토콜 				| 			인터페이스
						약속	:동등한 관계에서의 약속				:상하관계가 존재하는 약속
		즉 JPA는 자바 프로그래밍을 할 때 영구적으로 데이터 저장에 필요한 인터페이스

	2. ORM 기술이다.
		Object Relational Mapping
			원래 데이터 테이블을 만들고 이를 Input(DML: delete,update,insert),Output 하기 위해 DB상의 데이터를 자바로 모델링
			but TRM(Table)이 아니라 ORM이므로 자바 class를 먼저 만들고 이를 통해서 DB에 테이블이 자동생성되도록 만드는 것이 가능하다. 
			이때 필요한게 JPA에 있는 인터페이스

	3. 반복적인 CRUD 작업을 생략하게 해준다.
		자바가 CRUD(create:insert, read:select, update, delete)작업을 할 때 
		원래라면 자바가 DB에 데이터 요청을 하고, DB는 세션오픈을 한 후 다시 자바에서 쿼리를 전송하고 DB가 데이터를 전송하고 
		이를 JAVA가 읽을 수 있는 형태로 변경해야 한다.(단순 반복 로직)
		but JPA를 사용하면 이 모든 일련의 작업들을 하나의 함수로 제공함

	4. 영속성 컨텍스트를 가지고 있다.
		영속성: 데이터를 영구적으로 저장 persistance(DB에 저장(MySQL))
		컨텍스트: context
			대상에 대한 모든 정보를 가지고 있다라는 뜻.
		영속성 컨텍스트: 자바가 DB에 저장해야 하는 모든 대상에 대한 정보를 가지고 있다.
			그리고 영속성컨텍스트에 있는 데이터와 DB에 있는 데이터는 동기화되어 있다.
		ex>	
			자바		영속성컨텍스트 			DB
		select(데이터)->	DB에 요청		->데이터
			데이터<-데이터(자바오브젝트 타입)<-데이터(DB 타입)
			위의 3개의 데이터는 동일함(동기화)
			하나의 데이터가 변경되면 다른 곳의 데이터가 update됨 ==>영속성 컨텍스트
		
	5. JPA는 DB와 OOP(객체지향)의 불일치성을 해결하기 위한 방법론을 제공한다.(DB는 객체저장이 불가능하지만 자바는 객체저장이 가능하다)
		테이블에는 기본자료형만 들어가고 object는 들어갈 수 없지만, Java는 object안에 object를 넣을 수 있다.
		자바는 ORM이 있기 때문에 자바가 주도권을 가진 모델을 만들 수 있다.
		이렇게 들어간 데이터는 CRUD할 때 JPA가 자동으로 Mapping함

	6. JPA는 OOP관점에서 모델링 할 수 있게 해준다.(상속, 컴포지션, 연관관계)

	7. 방언처리가 용이하여 Migration하기 좋고 유지보수에도 좋다.
		spring-> JPA-> 추상화객체->DB
			ex> MySQL, 오라클, 마리아, MSSQL...(추상화 객체가 앞의 것으로 바뀜)
